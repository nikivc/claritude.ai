<!doctype html>
<html class="h-full bg-white dark:bg-gray-900">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>claritude helps you think</title>
    <script defer src="//cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script
      defer
      src="//cdn.jsdelivr.net/npm/@tailwindplus/elements@1"
      type="module"
    ></script>
    <script defer src="//unpkg.com/alpinejs"></script>
    <script
      defer
      src="//cdn.jsdelivr.net/npm/fabric@6.4.3/dist/index.js"
    ></script>
  </head>

  <body class="h-full w-full" x-data="mindMap">
    <!-- Mind Map Canvas -->
    <div class="h-full w-full">
      <canvas id="mindmap-canvas" class="h-full w-full"></canvas>
    </div>

    <!-- Chat Input -->
    <div class="fixed inset-x-0 bottom-3 mx-auto w-1/2">
      <div>
        <div class="mt-2">
          <textarea
            id="chat"
            name="chat"
            rows="4"
            class="block w-full rounded-md bg-white px-3 py-1.5 text-base text-gray-900 outline-1 -outline-offset-1 outline-gray-300 placeholder:text-gray-400 focus:outline-2 focus:-outline-offset-2 focus:outline-indigo-600 sm:text-sm/6 dark:bg-white/5 dark:text-white dark:outline-white/10 dark:placeholder:text-gray-500 dark:focus:outline-indigo-500"
          ></textarea>
        </div>
      </div>
    </div>

    <script>

      const mindmapNodes = [
        {
          id: "id1",
          text: "main idea",
          parent: null // This is the root item
        },
        {
          id: "id2",
          text: "Branch A",
          parent: "id1"
        },
        {
          id: "id3",
          text: "Branch B",
          parent: "id1"
        },
        {
          id: "id4",
          text: "Branch C",
          parent: "id1"
        },
        {
          id: "id5",
          text: "Another level A",
          parent: "id2"
        },
        {
          id: "id6",
          text: "Another level B",
          parent: "id2"
        },
        {
          id: "id7",
          text: "Another level C",
          parent: "id3"
        }
      ];


        document.addEventListener('alpine:init', () => {
          Alpine.data('mindMap', () => ({
            canvas: null,

            init() {
              this.$nextTick(() => {
                this.initCanvas();
              });
            },

            initCanvas() {
              // Initialize Fabric.js canvas
              this.canvas = new fabric.Canvas('mindmap-canvas', {
                width: window.innerWidth,
                height: window.innerHeight,
                backgroundColor: '#f8fafc'
              });

              this.createMindMap();
              this.setupResizeHandler();
            },

            createMindMap() {
              // Clear canvas
              this.canvas.clear();

              // Store nodes and connections for dynamic updates
              this.nodes = {};
              this.connections = [];

              // Build tree structure from mindMapNodes
              this.buildTreeStructure();
              
              // Calculate positions for all nodes
              this.calculateNodePositions();
              
              // Create connections between nodes FIRST (so they render behind)
              this.createAllConnections();
              
              // Render all nodes AFTER connections (so they render on top)
              this.renderNodes();

              // Set up movement handlers for dynamic connections
              this.setupMovementHandlers();

              // Render the canvas
              this.canvas.renderAll();
            },

            buildTreeStructure() {
              // Create a map for quick lookup
              this.nodeMap = {};
              this.treeStructure = {};

              // First pass: create node map
              mindmapNodes.forEach(node => {
                this.nodeMap[node.id] = {
                  ...node,
                  children: [],
                  level: 0,
                  position: { x: 0, y: 0 }
                };
              });

              // Second pass: build tree structure
              mindmapNodes.forEach(node => {
                if (node.parent === null) {
                  this.treeStructure = this.nodeMap[node.id];
                  this.treeStructure.level = 0;
                } else if (this.nodeMap[node.parent]) {
                  this.nodeMap[node.parent].children.push(this.nodeMap[node.id]);
                  this.nodeMap[node.id].level = this.nodeMap[node.parent].level + 1;
                }
              });
            },

            calculateNodePositions() {
              if (!this.treeStructure) return;

              const centerX = this.canvas.width / 2;
              const centerY = this.canvas.height / 2;
              const levelSpacing = 200;
              const siblingSpacing = 150;

              // Position root node at center
              this.treeStructure.position = { x: centerX, y: centerY };

              // Position children recursively
              this.positionChildren(this.treeStructure, levelSpacing, siblingSpacing);
            },

            positionChildren(node, levelSpacing, siblingSpacing) {
              if (!node.children || node.children.length === 0) return;

              const childCount = node.children.length;
              const startAngle = -Math.PI / 2; // Start from top
              const angleStep = (2 * Math.PI) / childCount;

              node.children.forEach((child, index) => {
                const angle = startAngle + (index * angleStep);
                const distance = levelSpacing;
                
                child.position = {
                  x: node.position.x + Math.cos(angle) * distance,
                  y: node.position.y + Math.sin(angle) * distance
                };

                // Recursively position grandchildren
                this.positionChildren(child, levelSpacing * 0.8, siblingSpacing);
              });
            },

            renderNodes() {
              // Render all nodes
              Object.values(this.nodeMap).forEach(nodeData => {
                this.createNode(nodeData);
              });
            },

            createNode(nodeData) {
              const isRoot = nodeData.parent === null;
              const fontSize = isRoot ? 16 : 12;
              const colors = [
                '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', 
                '#06b6d4', '#84cc16', '#f97316', '#ec4899', '#6366f1'
              ];
              const colorIndex = nodeData.level % colors.length;
              const fillColor = colors[colorIndex];
              const strokeColor = this.darkenColor(fillColor, 0.2);

              // Calculate text dimensions using canvas context
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              ctx.font = `bold ${fontSize}px Arial`;
              const textMetrics = ctx.measureText(nodeData.text);
              const textWidth = textMetrics.width;
              const textHeight = fontSize * 1.2; // Approximate line height
              
              const padding = isRoot ? 20 : 15;
              const boxWidth = Math.max(textWidth + padding * 2, isRoot ? 120 : 80);
              const boxHeight = textHeight + padding * 2;
              const cornerRadius = isRoot ? 12 : 8;

              // Create text object
              const nodeText = new fabric.Text(nodeData.text, {
                left: 0,
                top: 0,
                fontSize: fontSize,
                fill: 'white',
                fontWeight: 'bold',
                originX: 'center',
                originY: 'center',
                textAlign: 'center'
              });

              // Create rounded rectangle box
              const nodeBox = new fabric.Rect({
                left: 0,
                top: 0,
                width: boxWidth,
                height: boxHeight,
                fill: fillColor,
                stroke: strokeColor,
                strokeWidth: isRoot ? 3 : 2,
                rx: cornerRadius,
                ry: cornerRadius,
                originX: 'center',
                originY: 'center'
              });

              // Create group
              const nodeGroup = new fabric.Group([nodeBox, nodeText], {
                left: nodeData.position.x,
                top: nodeData.position.y,
                selectable: true,
                hasControls: true,
                hasBorders: true
              });

              // Store reference
              this.nodes[nodeData.id] = nodeGroup;
              this.canvas.add(nodeGroup);
            },

            createAllConnections() {
              // Create connections between parent and child nodes
              Object.values(this.nodeMap).forEach(nodeData => {
                if (nodeData.parent !== null) {
                  this.createConnection(nodeData.parent, nodeData.id);
                }
              });
            },

            darkenColor(color, factor) {
              // Simple color darkening function
              const hex = color.replace('#', '');
              const r = Math.max(0, parseInt(hex.substr(0, 2), 16) * (1 - factor));
              const g = Math.max(0, parseInt(hex.substr(2, 2), 16) * (1 - factor));
              const b = Math.max(0, parseInt(hex.substr(4, 2), 16) * (1 - factor));
              return `#${Math.floor(r).toString(16).padStart(2, '0')}${Math.floor(g).toString(16).padStart(2, '0')}${Math.floor(b).toString(16).padStart(2, '0')}`;
            },

            createConnection(fromNodeId, toNodeId) {
              const fromNodeData = this.nodeMap[fromNodeId];
              const toNodeData = this.nodeMap[toNodeId];

              if (!fromNodeData || !toNodeData) return;

              // Calculate connection points (center of node positions)
              const fromCenter = {
                x: fromNodeData.position.x,
                y: fromNodeData.position.y
              };
              const toCenter = {
                x: toNodeData.position.x,
                y: toNodeData.position.y
              };

              // Create line connecting the nodes
              const line = new fabric.Line([
                fromCenter.x, fromCenter.y,
                toCenter.x, toCenter.y
              ], {
                stroke: '#374151',
                strokeWidth: 2,
                selectable: false,
                evented: false
              });

              // Store connection info
              this.connections.push({
                line: line,
                from: fromNodeId,
                to: toNodeId
              });

              this.canvas.add(line);
            },

            updateConnections() {
              this.connections.forEach(connection => {
                const fromGroup = this.nodes[connection.from];
                const toGroup = this.nodes[connection.to];

                const fromCenter = {
                  x: fromGroup.left + fromGroup.width / 2,
                  y: fromGroup.top + fromGroup.height / 2
                };
                const toCenter = {
                  x: toGroup.left + toGroup.width / 2,
                  y: toGroup.top + toGroup.height / 2
                };

                connection.line.set({
                  x1: fromCenter.x,
                  y1: fromCenter.y,
                  x2: toCenter.x,
                  y2: toCenter.y
                });
              });

              this.canvas.renderAll();
            },

            setupMovementHandlers() {
              // Add movement handlers to all groups
              Object.values(this.nodes).forEach(group => {
                group.on('moving', () => {
                  this.updateConnections();
                });
                group.on('moved', () => {
                  this.updateConnections();
                });
              });
            },

            setupResizeHandler() {
              window.addEventListener('resize', () => {
                this.canvas.setDimensions({
                  width: window.innerWidth,
                  height: window.innerHeight
                });
                this.createMindMap();
              });
            }
          }));
        });
    </script>
  </body>
</html>
